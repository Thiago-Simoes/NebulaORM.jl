    📁 build/
    �� make.jl
      🔹 Conteúdo inicial:
        ```
        import Pkg Pkg.activate(".") using Documenter, OrionORM  push!(LOAD_PATH,"../src/") makedocs(     sitename="OrionORM.jl",     modules=[OrionORM],     pages = [     "Home" => "index.md",     "Manual" => ["manual/start.md", "manual/relationship.md"],     "Reference" => ["Reference/API.md"]     ] ) ...
        ```

    📁 src/
    �� OrionORM.jl
      🔹 Conteúdo inicial:
        ```
        module OrionORM  using DBInterface using MySQL using UUIDs using DotEnv using DataFrames using Dates using Logging  include("./pool.jl") include("./dbconnection.jl") include("./types.jl") include("./keys.jl") include("./others.jl") include("./models.jl") include("./relationships.jl") include("./querybuilder.jl") include("./crud.jl")   # --------------------------- # Global registry for associating model metadata (using the model name as key) const modelRegistry = Dict{Symbol, Model}()  # Global registry for associating model relationships (using the model name as key) const relationshipsRegistry = Dict{Symbol, Vector{Relationship}}() const __ORM_MODELS__ = Dict{Symbol, Tuple{Any, Any}}() __ORM_INITIALIZED__ = false       # Automatic initialization only if not precompiling function __init__()     initLogger()     global __ORM_INITIALIZED__ = true end     export dbConnection, createTableDefinition, migrate!, dropTable!,        Model, generateUuid,        findMany, findFirst, findFirstOrThrow, findUnique, findUniqueOrThrow,        create, update, upsert, delete, createMany, createManyAndReturn,        updateMany, updateManyAndReturn, deleteMany, hasMany, belongsTo, hasOne,        VARCHAR, TEXT, NUMBER, DOUBLE, FLOAT, INTEGER, UUID, DATE, TIMESTAMP, JSON, PrimaryKey, AutoIncrement, NotNull, Unique, Default   end  # module ORM ...
        ```

    �� crud.jl
      🔹 Conteúdo inicial:
        ```
        # Logger initialization based on environment variable "LOG_LEVEL" function initLogger()     lvl = lowercase(get(ENV, "OrionORM_LOG_LEVEL", "error"))     logLevel = lvl == "error" ? Logging.Error :                      lvl == "warn"  ? Logging.Warn  :                      lvl == "debug" ? Logging.Debug : Logging.Info     global_logger(SimpleLogger(stderr, logLevel))     @info "Logger configured" level=logLevel end  # Updated executeQuery function using logging function executeQuery(conn::MySQL.Connection, stmt::MySQL.Statement, args=[]; useTransaction::Bool=true)     @info "Executing query" query=stmt args=args transaction=useTransaction     try         if useTransaction             ret = DataFrame()             DBInterface.transaction(conn) do                 ret = DBInterface.execute(stmt, args)             end             return ret         else             return DBInterface.execute(stmt, args)         end     catch e         @error "SQL error occurred $(e)" query=stmt args=args     end end function executeQuery(conn::MySQL.Connection, stmt::String; useTransaction::Bool=true)     @info "Executing query" query=stmt transaction=useTransaction     try         if useTransaction             ret = DataFrame()             DBInterface.transaction(conn) do                 ret = DBInterface.execute(conn, stmt)             end             return ret         else             return DBInterface.execute(conn, stmt)         end     catch e         @error "SQL error occurred $(e)" query=stmt     end end  function dropTable!(conn, tableName::String)     query = "DROP TABLE IF EXISTS " * tableName     stmt = DBInterface.prepare(conn, query)     executeQuery(conn, stmt, []) end   function findMany(model::DataType; query::Dict = Dict())     query = normalizeQueryDict(query)     local resolved = resolveModel(model)     local sqlQuery = buildSqlQuery(resolved, query)     local conn = dbConnection()     local stmt = DBInterface.prepare(conn, sqlQuery)     local df = executeQuery(conn, stmt, []) |> DataFrame     return [ instantiate(resolved, row) for row in eachrow(df) ] end  """     advancedFindMany(model::DataType; query::AbstractDict = Dict()) Realiza uma consulta avançada no modelo base. """ function advancedFindMany(model::DataType; query::AbstractDict = Dict())     query = normalizeQueryDict(query)     local resolved = resolveModel(model)     local sqlQuery = buildSqlQuery(resolved, query)     local conn = dbConnection()     local stmt = DBInterface.prepare(conn, sqlQuery)     local df = executeQuery(conn, stmt, []) |> DataFrame     local results = [ instantiate(resolved, row) for row in eachrow(df) ]      if haskey(query, "include")         local enrichedResults = []         for rec in results             local result = serialize(rec)             for included in query["include"]                 local includedModel = included                 if isa(included, String)                     includedModel = Base.eval(@__MODULE__, Symbol(included))                 end                 local relationships = getRelationships(resolved)                 for rel in relationships                     if resolveModel(rel.targetModel) == includedModel                         local related = nothing                         if rel.type == :hasMany                             related = hasMany(rec, rel.field)                             related = [serialize(r) for r in related]                         elseif rel.type == :hasOne                             related = hasOne(rec, rel.field)                             if related !== nothing                                 related = serialize(related)                             end                         elseif rel.type == :belongsTo                             related = belongsTo(rec, rel.field)                             if related !== nothing                                 related = serialize(related)                             end                         end                         result[string(includedModel)] = related                         break                     end                 end             end             push!(enrichedResults, result)         end         return enrichedResults     else         return results     end end   function findFirst(model::DataType; query::Dict = Dict())     query = normalizeQueryDict(query)     local resolved = resolveModel(model)     if !haskey(query, "limit")         query["limit"] = 1     end     local sqlQuery = buildSqlQuery(resolved, query)     local conn = dbConnection()     local stmt = DBInterface.prepare(conn, sqlQuery)     local df = executeQuery(conn, stmt, []) |> DataFrame     if isempty(df)         return nothing     end     local record = instantiate(resolved, first(df))          # Se "include" estiver presente, enriquece o registro     if haskey(query, "include")         local result::Dict{String, Any} = Dict(string(resolved) => record)          # Para cada modelo incluído, busca os registros relacionados         for included in query["include"]             local includedModel = included             # Se o item incluído for string, converte para tipo             if isa(included, String)                 includedModel = Base.eval(@__MODULE__, Symbol(included))             end             local relationships = getRelationships(resolved)             for rel in relationships                 if string(resolveModel(rel.targetModel)) == string(includedModel)                     local related = nothing                     if rel.type == :hasMany                         related = hasMany(record, rel.field)                         # Converte cada registro relacionado para dict                         related = [r for r in related]                     elseif rel.type == :hasOne                         related = hasOne(record, rel.field)                         if related !== nothing                             related = related                         end                     elseif rel.type == :belongsTo                         related = belongsTo(record, rel.field)                         if related !== nothing                             related = related                         end                     end                     result[string(includedModel)] = related                     break                 end             end         end         return result     else         return record     end end  function findFirstOrThrow(model::DataType; query=Dict())     local rec = findFirst(model; query=query)     rec === nothing && error("No record found")     return rec end  function findUnique(model::DataType, uniqueField, value; query::AbstractDict = Dict())     query = normalizeQueryDict(query)     local resolved = resolveModel(model)     if haskey(query, "where")         if query["where"] isa Dict             query["where"][uniqueField] = value         else             error("The 'where' field must be a Dict")         end     else         query["where"] = Dict(uniqueField => value)     end     if !haskey(query, "limit")         query["limit"] = 1     end     local sqlQuery = buildSqlQuery(resolved, query)     local conn = dbConnection()     local stmt = DBInterface.prepare(conn, sqlQuery)     local df = executeQuery(conn, stmt, []) |> DataFrame     return isempty(df) ? nothing : instantiate(resolved, first(df)) end  function findUniqueOrThrow(model::DataType, uniqueField, value)     local rec = findUnique(model, uniqueField, value)     rec === nothing && error("No unique record found")     return rec end  function create(model::DataType, data::Dict)     local resolved = resolveModel(model)     local conn = dbConnection()     local modelFields = Set(String.(fieldnames(resolved)))     local filtered = Dict(k => v for (k,v) in data if k in modelFields)      local meta = modelConfig(resolved)     for col in meta.columns         if col.type == "VARCHAR(36)" && occursin("UUID", uppercase(join(col.constraints, " ")))             if !haskey(filtered, col.name)                 filtered[col.name] = generateUuid()             end         end     end      local cols = join(keys(filtered), ", ")     local placeholders = join(fill("?", length(keys(filtered))), ", ")     local vals = collect(values(filtered))     local queryStr = "INSERT INTO " * meta.name * " (" * cols * ") VALUES (" * placeholders * ")"     local stmt = DBInterface.prepare(conn, queryStr)     executeQuery(conn, stmt, vals)      for col in meta.columns         if occursin("UNIQUE", uppercase(join(col.constraints, " ")))             local uniqueValue = filtered[col.name]             return findFirst(resolved; query = Dict("where" => Dict(col.name => uniqueValue)))         end     end      local id_result = executeQuery(conn, "SELECT LAST_INSERT_ID()"; useTransaction=true) |> DataFrame     local id = first(id_result)[1]     local pkCol = getPrimaryKeyColumn(resolved)     if pkCol !== nothing         return findFirst(resolved; query = Dict("where" => Dict(pkCol.name => id)))     end      for col in meta.columns         if col.type == "VARCHAR(36)" && occursin("UUID", uppercase(join(col.constraints, " ")))             local uuid = filtered[col.name]             return findFirst(resolved; query = Dict("where" => Dict(col.name => uuid)))         end     end      error("Não foi possível recuperar o registro inserido.") end  function update(model::DataType, query::AbstractDict, data::Dict)     query = normalizeQueryDict(query)     local resolved = resolveModel(model)     local conn = dbConnection()     local modelFields = Set(String.(fieldnames(resolved)))     local filteredData = Dict(k => v for (k,v) in data if k in modelFields)     local assignments = join([ "$k = ?" for (k,_) in filteredData ], ", ")     local vals = collect(values(filteredData))          if !haskey(query, "where")         error("Query dict must have a 'where' clause for update")     end     local whereClause = ""     local wherePart = query["where"]     if isa(wherePart, String)         whereClause = wherePart     elseif isa(wherePart, Dict)         whereClause = buildWhereClause(wherePart)     else         error("Invalid type for 'where' clause")     end      local updateQuery = "UPDATE " * modelConfig(resolved).name * " SET " * assignments * " WHERE " * whereClause     local stmt = DBInterface.prepare(conn, updateQuery)     executeQuery(conn, stmt, vals)     return findFirst(resolved; query=query) end  function upsert(model::DataType, uniqueField, value, data::Dict)     local resolved = resolveModel(model)     local found = findUnique(resolved, uniqueField, value)     if found === nothing         return create(resolved, data)     else         local queryDict = Dict("where" => Dict(uniqueField => value))         return update(resolved, queryDict, data)     end end  function delete(model::DataType, query::Dict)     query = normalizeQueryDict(query)     local resolved = resolveModel(model)     local conn = dbConnection()     if !haskey(query, "where")         error("Query dict must have a 'where' clause for delete")     end     local whereClause = ""     local wherePart = query["where"]     if isa(wherePart, String)         whereClause = wherePart     elseif isa(wherePart, Dict)         whereClause = buildWhereClause(wherePart)     else         error("Invalid type for 'where' clause")     end      local deleteQuery = "DELETE FROM " * modelConfig(resolved).name * " WHERE " * whereClause     local stmt = DBInterface.prepare(conn, deleteQuery)     executeQuery(conn, stmt, [])     return true end  function createMany(model::DataType, dataList::Vector)     local resolved = resolveModel(model)     return [ create(resolved, data) for data in dataList ] end  function createManyAndReturn(model::DataType, dataList::Vector{Dict})     createMany(model, dataList)     local resolved = resolveModel(model)     return findMany(resolved) end  function updateMany(model::DataType, query, data::Dict)     local q = normalizeQueryDict(query)     if !haskey(q, "where")         error("Query dict must have a 'where' clause for updateMany")     end     local wherePart = q["where"]     local whereClause = ""     if isa(wherePart, String)         whereClause = wherePart     elseif isa(wherePart, Dict)         whereClause = buildWhereClause(wherePart)     else         error("Invalid type for 'where' clause")     end      local resolved = resolveModel(model)     local conn = dbConnection()     local assignments = join([ "$k = ?" for (k, _) in data ], ", ")     local vals = collect(values(data))     local updateQuery = "UPDATE " * modelConfig(resolved).name *                         " SET " * assignments *                         " WHERE " * whereClause     local stmt = DBInterface.prepare(conn, updateQuery)     executeQuery(conn, stmt, vals)     # Caso o 'where' seja um Dict, mescle com os dados atualizados.     if isa(q["where"], Dict)         q["where"] = merge(q["where"], data)     end     return findMany(resolved; query=q) end  function updateManyAndReturn(model::DataType, query, data::Dict)     local q = normalizeQueryDict(query)     updateMany(model, q, data)     local resolved = resolveModel(model)     return findMany(resolved; query=q) end  function deleteMany(model::DataType, query=Dict())     local q = normalizeQueryDict(query)     if !haskey(q, "where")         error("Query dict must have a 'where' clause for deleteMany")     end     local wherePart = q["where"]     local whereClause = ""     if isa(wherePart, String)         whereClause = wherePart     elseif isa(wherePart, Dict)         whereClause = buildWhereClause(wherePart)     else         error("Invalid type for 'where' clause")     end      local resolved = resolveModel(model)     local conn = dbConnection()     local deleteQuery = "DELETE FROM " * modelConfig(resolved).name *                         " WHERE " * whereClause     local stmt = DBInterface.prepare(conn, deleteQuery)     executeQuery(conn, stmt, [])     return true end  # Atualiza registro via método de instância usando query dict (sem aspas extras) function update(modelInstance)     local modelType = typeof(modelInstance)     local pkCol = getPrimaryKeyColumn(modelType)     pkCol === nothing && error("No primary key defined for model $(modelType)")     local pkName = pkCol.name     local id = getfield(modelInstance, Symbol(pkName))     local query = Dict("where" => Dict(pkName => id))     local data = Dict{String,Any}()     for field in fieldnames(modelType)         data[string(field)] = getfield(modelInstance, field)     end     return update(modelType, query, data) end  # Deleta registro via método de instância usando query dict function delete(modelInstance)     local modelType = typeof(modelInstance)     local pkCol = getPrimaryKeyColumn(modelType)     pkCol === nothing && error("No primary key defined for model $(modelType)")     local pkName = pkCol.name     local id = getfield(modelInstance, Symbol(pkName))     local query = Dict("where" => Dict(pkName => id))     return delete(modelType, query) end  function Base.filter(model::DataType; kwargs...)     return findMany(model; query=Dict("where" => Dict(kwargs...))) end...
        ```

    �� dbconnection.jl
      🔹 Conteúdo inicial:
        ```
        using DotEnv using MySQL using DBInterface using .Pool  # --------------------------- # Connection to the database # --------------------------- function dbConnection()     if isempty(Pool.connection_pool)         Pool.init_pool()     end     return Pool.getConnection() end...
        ```

    �� keys.jl
      🔹 Conteúdo inicial:
        ```
        # --------------------------- # This file contains the macros for the keys in the database. # --------------------------- function PrimaryKey()      :( "PRIMARY KEY" ) end  function AutoIncrement()     :( "AUTO_INCREMENT" ) end  function NotNull()     :( "NOT NULL" ) end  function Default(def)     "DEFAULT $(def)" end  function Unique()     :( "UNIQUE" ) end ...
        ```

    �� models.jl
      🔹 Conteúdo inicial:
        ```
        using Dates  function createTableDefinition(model::Model)     colDefs = String[]     keyDefs = String[]     for col in model.columns         constraints = copy(col.constraints)         colType = col.type         if occursin("TEXT", colType) && "UNIQUE" in constraints             deleteat!(constraints, findfirst(==("UNIQUE"), constraints))             push!(keyDefs, "UNIQUE KEY (`$(col.name)`(191))")         end         push!(colDefs, "$(col.name) $(colType) $(join(constraints, " "))")     end     allDefs = join(colDefs, ", ")     if !isempty(keyDefs)         allDefs *= ", " * join(keyDefs, ", ")     end     return allDefs end  function migrate!(conn, model::Model)     schema = createTableDefinition(model)     # Usar interpolação para o nome da tabela e schema; sem binding de valores para identificadores.     query = "CREATE TABLE IF NOT EXISTS " * model.name * " (" * schema * ")"     stmt = DBInterface.prepare(conn, query)     DBInterface.execute(stmt, []) end    """     Model(modelName::Symbol,                 columnsDef::Vector{<:Tuple{String,String,Vector{<:Any}}};                 relationshipsDef::Vector{<:Tuple{Symbol,Symbol,Symbol,Symbol}} = [])  Define um modelo em runtime, criando o `struct`, registrando-o no `modelRegistry`, executando a migração e cadastrando relacionamentos. """ function Model(modelName::Symbol,                      columnsDef::Vector,                      relationshipsDef::Vector = [])      # 1) Monta os campos do struct com tipos Julia     field_exprs = Vector{Expr}()     for (col_name, sql_type, _) in columnsDef         julia_ty = mapSqlTypeToJulia(sql_type)         push!(field_exprs, :( $(Symbol(col_name))::$(julia_ty) ))     end      # 2) Define dinamicamente o mutable struct com @kwdef     struct_expr = quote         Base.@kwdef mutable struct $(modelName)             $(field_exprs...)         end     end     @eval Main $struct_expr   # injeta no módulo Main      columns_vec = [ Column(name, sql_type, constraints)                      for (name, sql_type, constraints) in columnsDef ]      model_meta = Model(string(modelName), columns_vec, getfield(Main, modelName))     modelRegistry[Symbol(modelName)] = model_meta     conn = dbConnection()     migrate!(conn, model_meta)      if !isempty(relationshipsDef)         rel_objs = Relationship[]         for (fld, tgt, tgtfld, rtype) in relationshipsDef             push!(rel_objs,                  Relationship(string(fld), Symbol(tgt), string(tgtfld), rtype))             rev_type::Symbol = ((rtype == :belongsTo) ? :hasMany : (rtype == :hasMany ? :belongsTo : rtype))             rev_rel = Relationship("reverse_$(fld)_$(modelName)", modelName, string(fld), rev_type)             arr = get!(relationshipsRegistry, Symbol(tgt), Relationship[])             push!(arr, rev_rel)             relationshipsRegistry[Symbol(tgt)] = arr         end         relationshipsRegistry[Symbol(modelName)] = rel_objs     end      return getfield(Main, modelName) # retorna o tipo criado end   function resolveModel(modelRef)     if modelRef isa QuoteNode         modelRef = modelRef.value     end     if modelRef isa Symbol         ret::DataType = Base.eval(Main, modelRef)         return ret     elseif modelRef isa DataType         return modelRef     else         error("Referência de modelo inválida: $modelRef")     end end  # --------------------------- # Helpers: Metadados e conversão de registros # --------------------------- function modelConfig(model::DataType)     local key = nameof(model)     if haskey(modelRegistry, key)         return modelRegistry[key]     else         error("Model $(key) not registered")     end end  function getRelationships(model::DataType)     local key = nameof(model)     return get(relationshipsRegistry, key, []) end  function getPrimaryKeyColumn(model::DataType)     meta = modelConfig(model)     for col in meta.columns         if occursin("PRIMARY KEY", uppercase(join(col.constraints, " ")))             return col         end     end     return nothing end  function convertRowToDict(row, model::DataType)     meta = modelConfig(model)     d = Dict{String,Any}()     for (i, col) in enumerate(meta.columns)         d[col.name] = row[i]     end     return d end  function instantiate(model::DataType, record)     meta = modelConfig(model)     args = []     for (i, col) in enumerate(meta.columns)         value = record[i]         if value === missing             if col.type == "INTEGER"                 push!(args, 0)             elseif col.type in ["FLOAT", "DOUBLE"]                 push!(args, 0.0)             elseif col.type == "VARCHAR(36)" || col.type == "TEXT" || col.type == "JSON"                 push!(args, "")             elseif col.type == "DATE"                 push!(args, Date("1900-01-01"))             elseif col.type == "TIMESTAMP"                 push!(args, DateTime("1900-01-01T00:00:00"))             else                 push!(args, nothing)             end         else             push!(args, value)         end     end     return model(args...) end ...
        ```

    �� others.jl
      🔹 Conteúdo inicial:
        ```
        function getLastInsertId(conn)     result = DBInterface.execute(conn, "SELECT LAST_INSERT_ID() as id")     row = first(result) |> DataFrame     return row[1, :id] end   function serialize(instance)     local d = Dict{String,Any}()     for field in fieldnames(typeof(instance))         d[string(field)] = getfield(instance, field)     end     return d end   function generateUuid()     return string(uuid4()) end ...
        ```

    �� pool.jl
      🔹 Conteúdo inicial:
        ```
        module Pool  using DBInterface using MySQL using DotEnv  # Lê POOL_SIZE do ENV ou usa 5 se não definido const POOL_SIZE = get(ENV, "POOL_SIZE", "5") |> x -> parse(Int, x) const connection_pool = Channel{MySQL.Connection}(POOL_SIZE)  # Cria uma nova conexão function create_connection()     dbHost     = ENV["DB_HOST"]     dbUser     = ENV["DB_USER"]     dbPassword = ENV["DB_PASSWORD"]     dbName     = ENV["DB_NAME"]     dbPort     = parse(Int, string(ENV["DB_PORT"]))     return DBInterface.connect(MySQL.Connection, dbHost, dbUser, dbPassword, db=dbName, port=dbPort, reconnect=true) end  function init_pool()     # Limpa conexões existentes, se houver     while isready(connection_pool)         take!(connection_pool)     end     # DotEnv.load!()  # se necessário     for _ in 1:POOL_SIZE         conn = create_connection()         put!(connection_pool, conn)     end end  # Verifica se a conexão está ativa; se não, cria nova. function validate_connection(conn)     try         DBInterface.execute(conn, "SELECT 1")         return conn     catch         return create_connection()     end end  function getConnection()     local conn = take!(connection_pool)      # Verifica se conexões disponíveis estão abaixo da metade do pool     if connection_pool.n_avail_items < ceil(Int, POOL_SIZE / 2)         Threads.@spawn :interactive begin             while length(connection_pool) < POOL_SIZE                 new_conn = create_connection()                 put!(connection_pool, new_conn)             end         end     end     return conn end  function releaseConnection(conn)     put!(connection_pool, conn) end  export init_pool, getConnection, releaseConnection, connection_pool  end # module Pool ...
        ```

    �� querybuilder.jl
      🔹 Conteúdo inicial:
        ```
        # --------------------------- # Query Builder Inspired by Prisma.io # --------------------------- # Função auxiliar para construir a cláusula WHERE a partir de um Dict function buildWhereClause(whereDict::Dict)     conditions = String[]     for (key, val) in whereDict         if key == "endswith"             for (col, subStr) in val                 push!(conditions, "$col LIKE '%" * string(subStr) * "'")             end         elseif key == "startswith"             for (col, subStr) in val                 push!(conditions, "$col LIKE '" * string(subStr) * "%'")             end         elseif key == "contains"             for (col, subStr) in val                 push!(conditions, "$col LIKE '%" * string(subStr) * "%'")             end         elseif key == "not"             innerCondition = buildWhereClause(val)             push!(conditions, "NOT (" * innerCondition * ")")         elseif key == "in"             for (col, arr) in val                 valuesStr = join([isa(x, String) ? "'$x'" : string(x) for x in arr], ", ")                 push!(conditions, "$col IN (" * valuesStr * ")")             end         else             if isa(val, String)                 push!(conditions, "$key = '$val'")             else                 push!(conditions, "$key = " * string(val))             end         end     end     return join(conditions, " AND ") end  # Função auxiliar para construir cláusula JOIN com base em um relacionamento function buildJoinClause(rootModel::DataType, rel::Relationship)     local rootTable = modelConfig(rootModel).name     local includedModel = resolveModel(rel.targetModel)          # Verifica se o modelo incluído está registrado; caso contrário, lança um erro.     if !haskey(modelRegistry, nameof(includedModel))         error("Model $(nameof(includedModel)) not registered")     end     local includedTable = modelRegistry[nameof(includedModel)].name      if rel.type in (:hasMany, :hasOne)         local pkCol = getPrimaryKeyColumn(rootModel)         if pkCol === nothing             error("No primary key for model $(rootModel)")         end         local joinCondition = "$rootTable." * pkCol.name * " = $includedTable." * rel.targetField         return ("INNER", includedModel, joinCondition)     elseif rel.type == :belongsTo         local parentPk = getPrimaryKeyColumn(includedModel)         if parentPk === nothing             error("No primary key for model $(includedModel)")         end         local joinCondition = "$includedTable." * parentPk.name * " = $rootTable." * rel.field         return ("INNER", includedModel, joinCondition)     else         error("Unknown relationship type $(rel.type)")     end end  # Função principal para queries dinâmicas usando sintaxe inspirada no Prisma.io. # Suporta chaves: "where", "include", "orderBy", "limit", "offset", "select" function buildSqlQuery(model::DataType, queryDict::Dict)     local baseTable = modelConfig(model).name      # SELECT clause: se o usuário definiu "select", usa-o;     # senão, se "include" está presente, retorna apenas as colunas da tabela base.     local selectClause = ""     if haskey(queryDict, "select")         local selectFields = queryDict["select"]         if isa(selectFields, Vector)             selectClause = join(selectFields, ", ")         else             error("select must be a vector of fields")         end     else         if haskey(queryDict, "include")             selectClause = baseTable * ".*"         else             selectClause = "*"         end     end      local query = "SELECT " * selectClause * " FROM " * baseTable       # WHERE clause     if haskey(queryDict, "where")         local whereClause = buildWhereClause(queryDict["where"])         if whereClause != ""             query *= " WHERE " * whereClause         end     end      # ORDER BY     if haskey(queryDict, "orderBy")         query *= " ORDER BY " * string(queryDict["orderBy"])     end      # LIMIT e OFFSET     if haskey(queryDict, "limit")         query *= " LIMIT " * string(queryDict["limit"])         if haskey(queryDict, "offset")             query *= " OFFSET " * string(queryDict["offset"])         end     end      return query end   # Função auxiliar para normalizar query dict para Dict{String,Any} function normalizeQueryDict(query::AbstractDict)     normalized = Dict{String,Any}()     for (k, v) in query         normalized[string(k)] = v     end     return normalized end  using Dates  # Função interna para escapar strings (sem aspas externas) function sql_escape_raw(value::AbstractString)::String     clean = replace(value, "'" => "''")                          # Escapa aspas simples     clean = replace(clean, r"(--|#|;)" => "")                     # Remove comentários e separadores     clean = replace(clean, r"[\x00-\x1F\x7F]" => "")              # Remove caracteres de controle ASCII     clean = String(normalize(clean, stripmark=true, compat=true))  # Normaliza Unicode     return clean end  # Overloads para sql_escape sql_escape(x::Nothing) = "NULL" sql_escape(x::Bool) = x ? "TRUE" : "FALSE" sql_escape(x::Number) = string(x) sql_escape(x::Date) = "'$(Dates.format(x, "yyyy-mm-dd"))'" sql_escape(x::AbstractString) = "'" * sql_escape_raw(x) * "'" ...
        ```

    �� relationships.jl
      🔹 Conteúdo inicial:
        ```
         # --------------------------- # Relationship Helper Functions # --------------------------- # Versão registrada (usando metadados) function hasMany(parentInstance, relationName)     parentType = typeof(parentInstance)     relationships = getRelationships(parentType)     for rel in relationships         if rel.field == relationName && rel.type == :hasMany             pkCol = getPrimaryKeyColumn(parentType)             if pkCol === nothing                 error("No primary key defined for model $(parentType)")             end             parentValue = getfield(parentInstance, Symbol(pkCol.name))             return findMany(resolveModel(rel.targetModel); query=Dict("where" => Dict(rel.targetField => parentValue)))         end     end     error("No hasMany relationship found with name $relationName for model $(parentType)") end  # Overload para hasMany com 3 parâmetros function hasMany(parentInstance, relatedModel::DataType, foreignKey::String)     local parentType = typeof(parentInstance)     local pkCol = getPrimaryKeyColumn(parentType)     if pkCol === nothing         error("No primary key defined for model $(parentType)")     end     local parentValue = getfield(parentInstance, Symbol(pkCol.name))     return findMany(relatedModel; query=Dict("where" => Dict(foreignKey => parentValue))) end  # Versão registrada para belongsTo function belongsTo(childInstance, relationName)     childType = typeof(childInstance)     relationships = getRelationships(childType)     for rel in relationships         if rel.field == relationName && rel.type == :belongsTo             childFKValue = getfield(childInstance, Symbol(rel.field))             return findFirst(resolveModel(rel.targetModel); query=Dict("where" => Dict(rel.targetField => childFKValue)))         end     end     error("No belongsTo relationship found with name $relationName for model $(childType)") end  # Overload para belongsTo com 3 parâmetros function belongsTo(childInstance, relatedModel::DataType, foreignKey::String)     local childValue = getfield(childInstance, Symbol(foreignKey))     local pk = getPrimaryKeyColumn(relatedModel)     if pk === nothing         error("No primary key defined for model $(relatedModel)")     end     return findFirst(relatedModel; query=Dict("where" => Dict(pk.name => childValue))) end  # Versão registrada para hasOne function hasOne(parentInstance, relationName)     parentType = typeof(parentInstance)     relationships = getRelationships(parentType)     for rel in relationships         if rel.field == relationName && rel.type == :hasOne             pkCol = getPrimaryKeyColumn(parentType)             if pkCol === nothing                 error("No primary key defined for model $(parentType)")             end             local parentValue = getfield(parentInstance, Symbol(pkCol.name))             return findFirst(resolveModel(rel.targetModel); query=Dict("where" => Dict(rel.targetField => parentValue)))         end     end     error("No hasOne relationship found with name $relationName for model $(parentType)") end  # Overload para hasOne com 3 parâmetros function hasOne(parentInstance, relatedModel::DataType, foreignKey::String)     local parentType = typeof(parentInstance)     local pkCol = getPrimaryKeyColumn(parentType)     if pkCol === nothing         error("No primary key defined for model $(parentType)")     end     local parentValue = getfield(parentInstance, Symbol(pkCol.name))     return findFirst(relatedModel; query=Dict("where" => Dict(foreignKey => parentValue))) end...
        ```

    �� types.jl
      🔹 Conteúdo inicial:
        ```
        using Dates  # Pre-defined SQL type constructors # Are macros  function VARCHAR(size)     return "VARCHAR($(size))" end  function TEXT()     return :( "TEXT" ) end  function INTEGER()     return :( "INTEGER" ) end  function DOUBLE()     return :( "DOUBLE" ) end  function FLOAT()     return :( "FLOAT" ) end  function UUID()     return :( "VARCHAR(36)" ) end  function DATE()     return :( "DATE" ) end  function TIMESTAMP()     return :( "TIMESTAMP" ) end  function JSON()     return :( "JSON" ) end  # --------------------------- # Base structs # --------------------------- Base.@kwdef mutable struct Column     name::String     type::String     constraints::Vector{String} = String[] end  Base.@kwdef mutable struct Model     name::String     columns::Vector{Column}     modelType::DataType end  Base.@kwdef mutable struct Relationship     field::String     targetModel::Union{DataType, Symbol, QuoteNode}     targetField::String     type::Symbol  # :hasOne, :hasMany, :belongsTo end   # --------------------------- # Type functions # --------------------------- # --------------------------- function mapSqlTypeToJulia(sqlType::String)     sqlType = uppercase(sqlType)     if sqlType == "INTEGER"         return Int     elseif sqlType in ["FLOAT", "DOUBLE"]         return Float64     elseif sqlType == "TEXT"         return String     elseif sqlType == "TIMESTAMP"         return Dates.DateTime     elseif sqlType == "DATE"         return Dates.Date     elseif sqlType == "JSON"         return String     elseif sqlType == "UUID"         return String     else         return Any     end end ...
        ```

    �� runtests.jl
      🔹 Conteúdo inicial:
        ```
        # Implementa os testes unitários para o módulo `ORM.jl` e suas dependências. import Pkg Pkg.activate("..") # ... incluir outros arquivos de teste conforme necessário ...  using Test using Dates using DotEnv  DotEnv.load!()   using OrionORM  # Setup: Obter conexão e dropar as tabelas de teste, se existirem conn = dbConnection() dropTable!(conn, "User") dropTable!(conn, "Post")  # Define um modelo de teste com chave primária "id" Model(     :User,     [         ("id", INTEGER(), [PrimaryKey(), AutoIncrement()]),         ("name", VARCHAR(50), [NotNull()]),         ("email", TEXT(), [Unique(), NotNull()])     ] )  Model(     :Post,     [         ("id", INTEGER(), [PrimaryKey(), AutoIncrement()]),         ("title", TEXT(), [NotNull()]),         ("authorId", INTEGER(), [NotNull()]),         ("createdAt", TIMESTAMP(), [NotNull(), Default("CURRENT_TIMESTAMP()")])     ],     [         ("authorId", User, "id", :belongsTo)     ] )   @testset verbose = true "OrionORM" begin     @testset "OrionORM Basic CRUD Tests" begin         # ------------------------------         # Teste: Criar um registro         # ------------------------------         userData = Dict("name" => "Thiago", "email" => "thiago@example.com", "cpf" => "00000000000")         user = create(User, userData)         @test user.name == "Thiago"         @test user.email == "thiago@example.com"         @test hasproperty(user, :id)  # A chave primária deve estar definida          # ------------------------------         # Teste: Buscar registro com filtro (usando query dict)         # ------------------------------         foundUser = findFirst(User; query=Dict("where" => Dict("name" => "Thiago")))         @test foundUser !== nothing         @test foundUser.id == user.id          # ------------------------------         # Teste: Atualizar registro usando função update com query dict         # ------------------------------         updatedUser = update(User, Dict("where" => Dict("id" => user.id)), Dict("name" => "Thiago Updated"))         @test updatedUser.name == "Thiago Updated"          # ------------------------------         # Teste: Upsert - atualizar se existir, criar se não existir         # ------------------------------         upsertUser = upsert(User, "email", "thiago@example.com",                             Dict("name" => "Thiago Upserted", "email" => "thiago@example.com"))         @test upsertUser.name == "Thiago Upserted"          # ------------------------------         # Teste: Atualizar registro via método de instância         # ------------------------------         foundUser.name = "Thiago Instance"         updatedInstance = update(foundUser)         @test updatedInstance.name == "Thiago Instance"          # ------------------------------         # Teste: Deletar registro via método de instância         # ------------------------------         deleteResult = delete(foundUser)         @test deleteResult === true          # ------------------------------         # Teste: Criar múltiplos registros         # ------------------------------         records = [             Dict("name" => "Bob", "email" => "bob@example.com", "cpf" => "11111111111"),             Dict("name" => "Carol", "email" => "carol@example.com", "cpf" => "22222222222")         ]         createdRecords = createMany(User, records)         @test length(createdRecords) == 2          # ------------------------------         # Teste: Buscar vários registros (query dict vazio)         # ------------------------------         manyUsers = findMany(User)         @test length(manyUsers) ≥ 2          # ------------------------------         # Teste: Atualizar vários registros usando query dict         # ------------------------------         uMany = updateMany(User, Dict("where" => Dict("name" => "Bob")), Dict("name" => "Bob Updated"))         for u in uMany             @test u.name == "Bob Updated"         end          # ------------------------------         # Teste: Atualizar vários registros e retornar os registros atualizados         # ------------------------------         updatedManyAndReturn = updateManyAndReturn(User, Dict("where" => Dict("name" => "Carol")), Dict("name" => "Carol Updated"))         for u in updatedManyAndReturn             @test u.name == "Carol Updated"         end          # ------------------------------         # Teste: Criar registro relacionado (Post)         # ------------------------------         userData = Dict("name" => "Thiago", "email" => "thiago@example.com", "cpf" => "00000000000")         user = create(User, userData)         postData = Dict("title" => "My First Post", "authorId" => user.id)         post = create(Post, postData)         @test post.title == "My First Post"         @test post.authorId == user.id          # ------------------------------         # Teste: Buscar registros relacionados         # ------------------------------         @test hasMany(user, Post, "authorId")[1].title == "My First Post"          # ------------------------------         # Teste: Deletar vários registros usando query dict         # ------------------------------         deleteManyResult = deleteMany(User, Dict("where" => "1=1"))         @test deleteManyResult === true     end      @testset "OrionORM Relationships Tests" begin         userData = Dict("name" => "Thiago", "email" => "thiago@example.com", "cpf" => "00000000000")         user = create(User, userData)          foundUser = findFirst(User; query=Dict("where" => Dict("name" => "Thiago")))          postData = Dict("title" => "My First Post", "authorId" => user.id)         post = create(Post, postData)          userWithPosts = findFirst(User; query=Dict("where" => Dict("name" => "Thiago"), "include" => [Post]))         @test length(userWithPosts["Post"]) == 1         @test typeof(userWithPosts["Post"][1]) <: Post         @test userWithPosts["Post"][1].title == "My First Post"         @test userWithPosts["Post"][1].authorId == user.id      end      @testset "OrionORM Pagination Tests" begin         # Cria registros para paginação         # Limpa registros anteriores (se necessário)         deleteMany(User, Dict("where" => "1=1"))                  # Cria uma lista de 5 usuários com nomes numerados         usersData = [ Dict("name" => "User $(i)", "email" => "user$(i)@example.com", "cpf" => string(1000 + i)) for i in 1:5 ]         createdUsers = createMany(User, usersData)         @test length(createdUsers) == 5          # Teste: Recupera 2 usuários por vez, começando do primeiro         page1 = findMany(User; query=Dict("limit" => 2, "offset" => 0, "orderBy" => "id"))         @test length(page1) == 2         @test page1[1].name == "User 1"         @test page1[2].name == "User 2"          # Teste: Recupera os próximos 2 usuários a partir do terceiro         page2 = findMany(User; query=Dict("limit" => 2, "offset" => 2, "orderBy" => "id"))         @test length(page2) == 2         @test page2[1].name == "User 3"         @test page2[2].name == "User 4"          # Teste: Recupera os registros restantes         page3 = findMany(User; query=Dict("limit" => 2, "offset" => 4, "orderBy" => "id"))         @test length(page3) == 1         @test page3[1].name == "User 5"     end end # Cleanup: Opcionalmente dropar as tabelas de teste # dropTable!(conn, "User") # dropTable!(conn, "Post") ...
        ```

