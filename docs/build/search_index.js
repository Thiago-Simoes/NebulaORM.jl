var documenterSearchIndex = {"docs":
[{"location":"manual/start/#Quickstart","page":"Quickstart","title":"Quickstart","text":"","category":"section"},{"location":"manual/start/#How-to-config-ORM.jl","page":"Quickstart","title":"How to config ORM.jl","text":"","category":"section"},{"location":"manual/start/#Database-connection","page":"Quickstart","title":"Database connection","text":"","category":"section"},{"location":"manual/start/","page":"Quickstart","title":"Quickstart","text":"First you need configure database connection, just need to create a .env file in the root folder.  ","category":"page"},{"location":"manual/start/","page":"Quickstart","title":"Quickstart","text":"Containing:","category":"page"},{"location":"manual/start/","page":"Quickstart","title":"Quickstart","text":"DB_HOST=localhost\nDB_USER=root\nDB_PASSWORD=pass\nDB_NAME=dbname\nDB_PORT=3306","category":"page"},{"location":"manual/start/#How-to-perform-queries","page":"Quickstart","title":"How to perform queries","text":"","category":"section"},{"location":"manual/start/#How-to-create-a-Model","page":"Quickstart","title":"How to create a Model","text":"","category":"section"},{"location":"manual/start/","page":"Quickstart","title":"Quickstart","text":"using ORM\n\nModel(\n    :User,\n    [\n        (\"id\", INTEGER(), [PrimaryKey(), AutoIncrement()]),\n        (\"name\", TEXT(), [NotNull()]),\n        (\"email\", TEXT(), [Unique(), NotNull()]),\n        (\"cpf\", VARCHAR(11), [Unique(), NotNull()]),\n        (\"age\", INTEGER(), [])\n    ]\n)","category":"page"},{"location":"manual/start/#Inserting-data","page":"Quickstart","title":"Inserting data","text":"","category":"section"},{"location":"manual/start/","page":"Quickstart","title":"Quickstart","text":"The data should be formatted as a Dict.   Only NotNull fields need be provided.   The return can be either an error or a Model Object (a User object in this example).","category":"page"},{"location":"manual/start/","page":"Quickstart","title":"Quickstart","text":"userData = Dict(\"name\" => \"Thiago\", \"email\" => \"thiago@example.com\", \"cpf\" => \"00000000000\")\nuser = create(User, userData)","category":"page"},{"location":"manual/start/#Search-data","page":"Quickstart","title":"Search data","text":"","category":"section"},{"location":"manual/start/","page":"Quickstart","title":"Quickstart","text":"Now queries use a dictionary format:","category":"page"},{"location":"manual/start/","page":"Quickstart","title":"Quickstart","text":"foundUser = findFirst(User; query=Dict(\"where\" => Dict(\"name\" => \"Thiago\")))","category":"page"},{"location":"manual/start/#Update-data","page":"Quickstart","title":"Update data","text":"","category":"section"},{"location":"manual/start/","page":"Quickstart","title":"Quickstart","text":"updatedUser = update(User, Dict(\"where\" => Dict(\"id\" => user.id)), Dict(\"name\" => \"Thiago Updated\"))","category":"page"},{"location":"manual/start/#Upsert-data","page":"Quickstart","title":"Upsert data","text":"","category":"section"},{"location":"manual/start/","page":"Quickstart","title":"Quickstart","text":"upsertUser = upsert(User, \"email\", \"thiago@example.com\",\n                    Dict(\"name\" => \"Thiago Upserted\", \"email\" => \"thiago@example.com\"))","category":"page"},{"location":"manual/start/#Update-by-instance","page":"Quickstart","title":"Update by instance","text":"","category":"section"},{"location":"manual/start/","page":"Quickstart","title":"Quickstart","text":"foundUser.name = \"Thiago Instance\"\nupdatedInstance = update(foundUser)","category":"page"},{"location":"manual/start/#Delete-data","page":"Quickstart","title":"Delete data","text":"","category":"section"},{"location":"manual/start/","page":"Quickstart","title":"Quickstart","text":"deleteResult = delete(foundUser)","category":"page"},{"location":"manual/start/#Insert-multiple-records","page":"Quickstart","title":"Insert multiple records","text":"","category":"section"},{"location":"manual/start/","page":"Quickstart","title":"Quickstart","text":"records = [\n    Dict(\"name\" => \"Bob\", \"email\" => \"bob@example.com\", \"cpf\" => \"11111111111\"),\n    Dict(\"name\" => \"Carol\", \"email\" => \"carol@example.com\", \"cpf\" => \"22222222222\")\n]\ncreatedRecords = createMany(User, records)","category":"page"},{"location":"manual/start/#Find-multiple-records","page":"Quickstart","title":"Find multiple records","text":"","category":"section"},{"location":"manual/start/","page":"Quickstart","title":"Quickstart","text":"manyUsers = findMany(User)","category":"page"},{"location":"manual/start/#Update-many","page":"Quickstart","title":"Update many","text":"","category":"section"},{"location":"manual/start/","page":"Quickstart","title":"Quickstart","text":"updatedMany = updateMany(User, Dict(\"where\" => Dict(\"name\" => \"Bob\")), Dict(\"name\" => \"Bob Updated\"))","category":"page"},{"location":"manual/start/#Filter","page":"Quickstart","title":"Filter","text":"","category":"section"},{"location":"manual/start/","page":"Quickstart","title":"Quickstart","text":"_ = createMany(User, [\n    Dict(\"name\" => \"Dan\", \"email\" => \"dan@example.com\", \"cpf\" => \"33333333333\"),\n    Dict(\"name\" => \"Eve\", \"email\" => \"eve@example.com\", \"cpf\" => \"44444444444\")\n])\nfilteredUsers = filter(User; name=\"Dan\")","category":"page"},{"location":"manual/start/#Delete-multiple-records","page":"Quickstart","title":"Delete multiple records","text":"","category":"section"},{"location":"manual/start/","page":"Quickstart","title":"Quickstart","text":"deleteManyResult = deleteMany(User, Dict(\"where\" => \"1=1\"))","category":"page"},{"location":"manual/start/#Update-Many-and-Return","page":"Quickstart","title":"Update Many and Return","text":"","category":"section"},{"location":"manual/start/","page":"Quickstart","title":"Quickstart","text":"Updates multiple records and returns the updated records.","category":"page"},{"location":"manual/start/","page":"Quickstart","title":"Quickstart","text":"updatedManyAndReturn = updateManyAndReturn(User, Dict(\"where\" => Dict(\"name\" => \"Carol\")), Dict(\"name\" => \"Carol Updated\"))","category":"page"},{"location":"manual/start/#Pagination","page":"Quickstart","title":"Pagination","text":"","category":"section"},{"location":"manual/start/","page":"Quickstart","title":"Quickstart","text":"Retrieve query results using limit, offset, and ordering.","category":"page"},{"location":"manual/start/","page":"Quickstart","title":"Quickstart","text":"# Retrieve first 2 users\npage1 = findMany(User; query=Dict(\"limit\" => 2, \"offset\" => 0, \"orderBy\" => \"id\"))\n# Retrieve next 2 users starting from the third record\npage2 = findMany(User; query=Dict(\"limit\" => 2, \"offset\" => 2, \"orderBy\" => \"id\"))\n# Retrieve remaining records\npage3 = findMany(User; query=Dict(\"limit\" => 2, \"offset\" => 4, \"orderBy\" => \"id\"))","category":"page"},{"location":"manual/examples/#Examples-and-FAQ","page":"Examples & FAQ","title":"Examples & FAQ","text":"","category":"section"},{"location":"manual/examples/","page":"Examples & FAQ","title":"Examples & FAQ","text":"This guide provides advanced usage patterns, real‑world scenarios, and answers to frequently asked questions when working with OrionORM.","category":"page"},{"location":"manual/examples/","page":"Examples & FAQ","title":"Examples & FAQ","text":"","category":"page"},{"location":"manual/examples/#1.-Multiple-Includes","page":"Examples & FAQ","title":"1. Multiple Includes","text":"","category":"section"},{"location":"manual/examples/","page":"Examples & FAQ","title":"Examples & FAQ","text":"Fetch a User with both posts and another related model, e.g. Profile:","category":"page"},{"location":"manual/examples/","page":"Examples & FAQ","title":"Examples & FAQ","text":"results = findMany(User; query=Dict(\n  \"where\"   => Dict(\"active\"=>true),\n  \"include\" => [Post, Profile]\n))\n\n# Each element:\n# Dict(\n#   \"User\"    => User(...),\n#   \"Post\"    => Vector{Post}(...),\n#   \"Profile\" => Profile(...)\n# )","category":"page"},{"location":"manual/examples/","page":"Examples & FAQ","title":"Examples & FAQ","text":"Or filter children before include:","category":"page"},{"location":"manual/examples/","page":"Examples & FAQ","title":"Examples & FAQ","text":"results = findMany(User; query=Dict(\n  \"where\"   => Dict(\"Post\"=>Dict(\"contains\"=>\"Welcome\")),\n  \"include\" => [Post]\n))","category":"page"},{"location":"manual/examples/","page":"Examples & FAQ","title":"Examples & FAQ","text":"","category":"page"},{"location":"manual/examples/#2.-Raw-SQL-Fallback","page":"Examples & FAQ","title":"2. Raw SQL Fallback","text":"","category":"section"},{"location":"manual/examples/","page":"Examples & FAQ","title":"Examples & FAQ","text":"When you need custom SQL not yet supported by the QueryBuilder, you can still prepare and execute manually:","category":"page"},{"location":"manual/examples/","page":"Examples & FAQ","title":"Examples & FAQ","text":"sql = \"SELECT u.id, u.name, COUNT(p.id) AS post_count\"\n     * \" FROM User u LEFT JOIN Post p ON u.id=p.authorId\"\n     * \" WHERE u.active = ? GROUP BY u.id\"\nparams = [true]\n\ndf = executeQuery(sql, params)\n# Map results manually:\nusers = [ (\n    id         = row.id,\n    name       = row.name,\n    post_count = row.post_count\n  ) for row in eachrow(df)\n]","category":"page"},{"location":"manual/examples/","page":"Examples & FAQ","title":"Examples & FAQ","text":"","category":"page"},{"location":"manual/examples/#3.-Composite-Primary-Keys","page":"Examples & FAQ","title":"3. Composite Primary Keys","text":"","category":"section"},{"location":"manual/examples/","page":"Examples & FAQ","title":"Examples & FAQ","text":"OrionORM supports tables with multiple primary keys. Example:","category":"page"},{"location":"manual/examples/","page":"Examples & FAQ","title":"Examples & FAQ","text":"Model(\n  :Membership,\n  [\n    (\"userId\", INTEGER(), [PrimaryKey()]),\n    (\"groupId\", INTEGER(), [PrimaryKey()]),\n    (\"role\",   TEXT(),    [NotNull()])\n  ]\n)","category":"page"},{"location":"manual/examples/","page":"Examples & FAQ","title":"Examples & FAQ","text":"findFirst and update require a where dict including both keys:","category":"page"},{"location":"manual/examples/","page":"Examples & FAQ","title":"Examples & FAQ","text":"m = findFirst(Membership;\n      query=Dict(\"where\"=>Dict(\"userId\"=>1, \"groupId\"=>10))\n)","category":"page"},{"location":"manual/examples/","page":"Examples & FAQ","title":"Examples & FAQ","text":"","category":"page"},{"location":"manual/examples/#4.-FAQ","page":"Examples & FAQ","title":"4. FAQ","text":"","category":"section"},{"location":"manual/examples/","page":"Examples & FAQ","title":"Examples & FAQ","text":"Q1: How do I chain multiple operators on one column? A: Wrap them in a Dict, e.g.:","category":"page"},{"location":"manual/examples/","page":"Examples & FAQ","title":"Examples & FAQ","text":"findMany(User; query=Dict(\n  \"where\" => Dict(\n    \"age\" => Dict(\"gte\"=>18, \"lte\"=>30)\n  )\n))","category":"page"},{"location":"manual/examples/","page":"Examples & FAQ","title":"Examples & FAQ","text":"Q2: Why doesn’t findMany return a vector of Dict for simple queries? A: Only queries with include return Dict{String,Any}. Otherwise you get a Vector{Model}.","category":"page"},{"location":"manual/examples/","page":"Examples & FAQ","title":"Examples & FAQ","text":"Q3: How to inspect the raw SQL generated? A:","category":"page"},{"location":"manual/examples/","page":"Examples & FAQ","title":"Examples & FAQ","text":"b = buildSelectQuery(User, qdict)\nprintln(b.sql)\nprintln(\"Params: \", b.params)","category":"page"},{"location":"manual/examples/","page":"Examples & FAQ","title":"Examples & FAQ","text":"Q4: Can I use custom types or functions in filters? A: You can inject raw SQL via string in where:","category":"page"},{"location":"manual/examples/","page":"Examples & FAQ","title":"Examples & FAQ","text":"findMany(User; query=Dict(\"where\"=>\"LENGTH(name) > 5\"))","category":"page"},{"location":"Reference/API/#API","page":"API","title":"API","text":"","category":"section"},{"location":"Reference/API/#OrionORM.Model","page":"API","title":"OrionORM.Model","text":"Model(modelName::Symbol,\n            columnsDef::Vector{<:Tuple{String,String,Vector{<:Any}}};\n            relationshipsDef::Vector{<:Tuple{Symbol,Symbol,Symbol,Symbol}} = [])\n\nDefine um modelo em runtime, criando o struct, registrando-o no modelRegistry, executando a migração e cadastrando relacionamentos.\n\n\n\n\n\n","category":"type"},{"location":"Reference/API/#Base.filter-Tuple{DataType}","page":"API","title":"Base.filter","text":"filter(model::DataType; kwargs...)\n\nFilters records of model by the keyword arguments provided and returns the matching instances.\n\n\n\n\n\n","category":"method"},{"location":"Reference/API/#OrionORM._build_where-Tuple{Any}","page":"API","title":"OrionORM._build_where","text":"_build_where(where)::NamedTuple{(:clause,:params)}\n\nRecebe qualquer Dict compatível com a sintaxe Prisma e devolve clause::String (com placeholders ?) e params::Vector na ordem certa.\n\n\n\n\n\n","category":"method"},{"location":"Reference/API/#OrionORM.buildBatchInsertQuery-Tuple{DataType, AbstractVector}","page":"API","title":"OrionORM.buildBatchInsertQuery","text":"buildBatchInsertQuery(model::DataType, records::Vector{Dict{String,Any}})\n\nGenerates a single INSERT statement with placeholders for multiple records, returning (sql, params) suitable for prepared execution.\n\n\n\n\n\n","category":"method"},{"location":"Reference/API/#OrionORM.buildDeleteQuery-Tuple{DataType, Dict{<:AbstractString}}","page":"API","title":"OrionORM.buildDeleteQuery","text":"buildDeleteQuery(model::DataType, where::Dict)\n\nGera:   sql    = \"DELETE FROM table WHERE (…)\"; params = [where-params…]\n\n\n\n\n\n","category":"method"},{"location":"Reference/API/#OrionORM.buildInsertQuery-Tuple{DataType, Dict{<:AbstractString}}","page":"API","title":"OrionORM.buildInsertQuery","text":"buildInsertQuery(model::DataType, data::Dict{String,Any})\n\nGera:   sql    = \"INSERT INTO table (col1,col2,…) VALUES (?,?,…)\"   params = [val1, val2, …]\n\n\n\n\n\n","category":"method"},{"location":"Reference/API/#OrionORM.buildSelectQuery-Tuple{DataType, Dict}","page":"API","title":"OrionORM.buildSelectQuery","text":"buildSqlQuery(model::DataType, query::Dict)\n\nDevolve (sql,params) prontos para DBInterface.prepare/execute.\n\n\n\n\n\n","category":"method"},{"location":"Reference/API/#OrionORM.buildUpdateQuery-Tuple{DataType, Dict{<:AbstractString}, Dict{<:AbstractString}}","page":"API","title":"OrionORM.buildUpdateQuery","text":"buildUpdateQuery(model::DataType, data::Dict, where::Dict)\n\nGera:   sql    = \"UPDATE table SET col1 = ?, col2 = ? WHERE (…)\"   params = [val1, val2, …, [where-params…]]\n\n\n\n\n\n","category":"method"},{"location":"Reference/API/#OrionORM.create-Tuple{DataType, Dict{<:AbstractString}}","page":"API","title":"OrionORM.create","text":"create(model::DataType, data::Dict{String,Any})\n\nInserts a new record for model, auto-generating UUIDs when needed, and returns the created instance.\n\n\n\n\n\n","category":"method"},{"location":"Reference/API/#OrionORM.createMany-Tuple{DataType, Vector{<:Dict{String}}}","page":"API","title":"OrionORM.createMany","text":"createMany(model::DataType, data::Vector{<:Dict};\n           chunkSize::Int=1000, transaction::Bool=true)\n\nInserts multiple records in batches. Returns true on success.\n\n\n\n\n\n","category":"method"},{"location":"Reference/API/#OrionORM.delete-Tuple{Any}","page":"API","title":"OrionORM.delete","text":"delete(modelInstance)\n\nDeletes the record corresponding to modelInstance in the database using its primary key, and returns true on success.\n\n\n\n\n\n","category":"method"},{"location":"Reference/API/#OrionORM.delete-Tuple{DataType, AbstractDict}","page":"API","title":"OrionORM.delete","text":"delete(model::DataType, query::AbstractDict)\n\nDeletes records in model matching query[\"where\"] and returns true on success.\n\n\n\n\n\n","category":"method"},{"location":"Reference/API/#OrionORM.deleteMany","page":"API","title":"OrionORM.deleteMany","text":"deleteMany(model::DataType, query::AbstractDict=Dict())\n\nDeletes all records in model matching query[\"where\"] and returns true on success.\n\n\n\n\n\n","category":"function"},{"location":"Reference/API/#OrionORM.executeQuery","page":"API","title":"OrionORM.executeQuery","text":"executeQuery(conn::DBInterface.Connection, stmt::String, params::Vector{Any}=Any[]; useTransaction::Bool=true)\n\nPrepare and execute a SQL statement on the given connection, returning the result as a DataFrame for queries that return rows, or the raw result (e.g., number of affected rows) otherwise.\n\nArguments\n\nconn::DBInterface.Connection: The database connection to use.\nstmt::String: The SQL query string to prepare.\nparams::Vector{Any}: A vector of parameters to bind to the prepared statement (default: Any[]).\nuseTransaction::Bool: Whether to run the statement inside a new transaction (default: true). When false, the statement is executed without starting a transaction—useful if you are already inside DBInterface.transaction.\n\nReturns\n\nA DataFrame if the underlying result is tabular.\nOtherwise, returns the raw result from DBInterface.execute, such as the number of affected rows.\n\nThrows\n\nRethrows any exception raised during statement preparation or execution.\n\nReturns\n\nA DataFrame if the result is tabular.  \nOtherwise, the raw result (e.g. number of affected rows).\n\n\n\n\n\n","category":"function"},{"location":"Reference/API/#OrionORM.findUnique-Tuple{DataType, Any, Any}","page":"API","title":"OrionORM.findUnique","text":"findUnique(model::DataType, uniqueField, value; query=Dict())\n\nFinds a single record by a unique field. Returns an instance of the model if found, or nothing if no matching record exists.\n\n\n\n\n\n","category":"method"},{"location":"Reference/API/#OrionORM.update-Tuple{Any}","page":"API","title":"OrionORM.update","text":"update(modelInstance)\n\nUpdates the record corresponding to modelInstance in the database using its primary key, and returns the updated instance.\n\n\n\n\n\n","category":"method"},{"location":"Reference/API/#OrionORM.update-Tuple{DataType, AbstractDict, Dict{<:AbstractString}}","page":"API","title":"OrionORM.update","text":"update(model::DataType, query::AbstractDict, data::Dict{String,Any})\n\nUpdates records in model matching query[\"where\"] with the fields in data, and returns the first updated instance.\n\n\n\n\n\n","category":"method"},{"location":"Reference/API/#OrionORM.updateMany-Tuple{DataType, AbstractDict, Dict{<:AbstractString}}","page":"API","title":"OrionORM.updateMany","text":"updateMany(model::DataType, query, data::Dict{String,Any})\n\nUpdates all records matching query[\"where\"] with the given data and returns the updated instances.\n\n\n\n\n\n","category":"method"},{"location":"Reference/API/#OrionORM.updateManyAndReturn-Tuple{DataType, AbstractDict, Dict{<:AbstractString}}","page":"API","title":"OrionORM.updateManyAndReturn","text":"updateManyAndReturn(model::DataType, query::AbstractDict, data::Dict{String,Any})\n\nUpdates all records in model matching query[\"where\"] with the values in data and returns the updated instances.\n\n\n\n\n\n","category":"method"},{"location":"Reference/API/#OrionORM.upsert-Tuple{DataType, Any, Any, Dict{<:AbstractString}}","page":"API","title":"OrionORM.upsert","text":"upsert(model::DataType, uniqueField, value, data::Dict{String,Any})\n\nCreates a new record if none exists with the given unique field, otherwise updates the existing record.\n\n\n\n\n\n","category":"method"},{"location":"manual/transactions/#Transactions-and-Connection-Management","page":"Transactions","title":"Transactions & Connection Management","text":"","category":"section"},{"location":"manual/transactions/","page":"Transactions","title":"Transactions","text":"OrionORM provides both high-level and low-level APIs for executing database operations, giving you fine-grained control over transactions and connection lifecycles.","category":"page"},{"location":"manual/transactions/","page":"Transactions","title":"Transactions","text":"","category":"page"},{"location":"manual/transactions/#1.-Connection-Pooling","page":"Transactions","title":"1. Connection Pooling","text":"","category":"section"},{"location":"manual/transactions/","page":"Transactions","title":"Transactions","text":"dbConnection(): checks out a connection from the pool (auto-initializes if empty).\nreleaseConnection(conn): returns a connection to the pool or closes it if the pool is full.\nPool health: connections are validated (SELECT 1) before use; dropped ones are reconnected.","category":"page"},{"location":"manual/transactions/","page":"Transactions","title":"Transactions","text":"","category":"page"},{"location":"manual/transactions/#2.-executeQuery-APIs","page":"Transactions","title":"2. executeQuery APIs","text":"","category":"section"},{"location":"manual/transactions/#2.1-High-Level-(One-Shot)","page":"Transactions","title":"2.1 High-Level (One-Shot)","text":"","category":"section"},{"location":"manual/transactions/","page":"Transactions","title":"Transactions","text":"# Opens and closes the connection automatically.\nresult = executeQuery(\n  \"SELECT * FROM users WHERE active = ?\", [true]\n)","category":"page"},{"location":"manual/transactions/","page":"Transactions","title":"Transactions","text":"Signature: executeQuery(sql::String, params::Vector{Any}=Any[]; useTransaction::Bool=true)\nBehavior:\nChecks out a connection (dbConnection()).\nPrepares, executes, closes statement.\nCommits or rolls back DML if useTransaction=true.\nReleases connection (releaseConnection).","category":"page"},{"location":"manual/transactions/#2.2-Low-Level-(Conn-Aware)","page":"Transactions","title":"2.2 Low-Level (Conn-Aware)","text":"","category":"section"},{"location":"manual/transactions/","page":"Transactions","title":"Transactions","text":"conn = dbConnection()\nDBInterface.transaction(conn) do\n  executeQuery(conn, \"UPDATE accounts SET balance = balance - ? WHERE id = ?\", [100,1]; useTransaction=false)\n  executeQuery(conn, \"UPDATE accounts SET balance = balance + ? WHERE id = ?\", [100,2]; useTransaction=false)\nend\nreleaseConnection(conn)","category":"page"},{"location":"manual/transactions/","page":"Transactions","title":"Transactions","text":"Signature: executeQuery(conn::DBInterface.Connection, sql::String, params::Vector{Any}=Any[]; useTransaction::Bool=true)\nBehavior:\nUses your provided conn without closing it.\nIf useTransaction=true, wraps the single statement in its own transaction; otherwise executes raw.\nAlways closes the prepared statement in a finally block.","category":"page"},{"location":"manual/transactions/","page":"Transactions","title":"Transactions","text":"","category":"page"},{"location":"manual/transactions/#3.-Best-Practices","page":"Transactions","title":"3. Best Practices","text":"","category":"section"},{"location":"manual/transactions/","page":"Transactions","title":"Transactions","text":"One-shot queries: prefer the high-level API for isolated operations (SELECT, single INSERT, etc.).\nBatch updates/inserts: open a connection once, wrap multiple executeQuery(conn, ...; useTransaction=false) calls inside DBInterface.transaction, then release the connection.\nDo not nest transactions: avoid useTransaction=true inside DBInterface.transaction blocks—most drivers don’t support nested transactions.\nRelease in finally: always pair dbConnection() with releaseConnection(conn) in a try/finally.","category":"page"},{"location":"manual/transactions/","page":"Transactions","title":"Transactions","text":"","category":"page"},{"location":"manual/transactions/#4.-Example:-Atomic-Transfer","page":"Transactions","title":"4. Example: Atomic Transfer","text":"","category":"section"},{"location":"manual/transactions/","page":"Transactions","title":"Transactions","text":"function transfer_funds(from_id::Int, to_id::Int, amount::Float64)\n  conn = dbConnection()\n  try\n    DBInterface.transaction(conn) do\n      executeQuery(conn,\n        \"UPDATE accounts SET balance = balance - ? WHERE id = ?\", [amount, from_id];\n        useTransaction=false\n      )\n      executeQuery(conn,\n        \"UPDATE accounts SET balance = balance + ? WHERE id = ?\", [amount, to_id];\n        useTransaction=false\n      )\n    end\n  finally\n    releaseConnection(conn)\n  end\nend","category":"page"},{"location":"manual/transactions/","page":"Transactions","title":"Transactions","text":"All updates occur in a single transaction; on error, changes are rolled back.","category":"page"},{"location":"manual/transactions/","page":"Transactions","title":"Transactions","text":"","category":"page"},{"location":"manual/transactions/#5.-Troubleshooting","page":"Transactions","title":"5. Troubleshooting","text":"","category":"section"},{"location":"manual/transactions/","page":"Transactions","title":"Transactions","text":"Commands out of sync: ensure prepared statements are closed and connections are released promptly.\nZombie connections: monitor pool size and logs; improper releaseConnection usage can exhaust the pool.\nTransaction deadlocks: use retries or reduced transaction scope if needed.","category":"page"},{"location":"manual/bulk/#Bulk-Operations","page":"Bulk Operations","title":"Bulk Operations","text":"","category":"section"},{"location":"manual/bulk/","page":"Bulk Operations","title":"Bulk Operations","text":"OrionORM offers specialized functions for efficient, transactional bulk inserts and updates. These helpers minimize round-trips and leverage chunking to handle large datasets gracefully.","category":"page"},{"location":"manual/bulk/","page":"Bulk Operations","title":"Bulk Operations","text":"","category":"page"},{"location":"manual/bulk/#1.-Batch-Insert-Query-Builder","page":"Bulk Operations","title":"1. Batch Insert Query Builder","text":"","category":"section"},{"location":"manual/bulk/","page":"Bulk Operations","title":"Bulk Operations","text":"Generates a single SQL INSERT statement with placeholders for multiple records.","category":"page"},{"location":"manual/bulk/","page":"Bulk Operations","title":"Bulk Operations","text":"buildBatchInsertQuery(model::DataType,\n                      records::Vector{Dict{String,Any}})","category":"page"},{"location":"manual/bulk/","page":"Bulk Operations","title":"Bulk Operations","text":"Arguments:\nmodel: your DataType (e.g., User or Post).\nrecords: vector of Dict where each dict maps column names to values.\nReturns: NamedTuple(sql, params):\nsql: a string like\nINSERT INTO table_name (col1,col2,...) VALUES (?,?,?...),(?,?,?...),...\nparams: a flat Vector{Any} concatenating the values for all rows in order.","category":"page"},{"location":"manual/bulk/","page":"Bulk Operations","title":"Bulk Operations","text":"records = [Dict(\"name\"=>\"A\",\"email\"=>\"a@e.com\"),\n           Dict(\"name\"=>\"B\",\"email\"=>\"b@e.com\")]\nb = buildBatchInsertQuery(User, records)\n# b.sql    => \"INSERT INTO User (`name`,`email`) VALUES (?,?),(?,?)\"\n# b.params => [\"A\",\"a@e.com\",\"B\",\"b@e.com\"]","category":"page"},{"location":"manual/bulk/","page":"Bulk Operations","title":"Bulk Operations","text":"","category":"page"},{"location":"manual/bulk/#2.-createMany-–-Chunked,-Transactional-Inserts","page":"Bulk Operations","title":"2. createMany – Chunked, Transactional Inserts","text":"","category":"section"},{"location":"manual/bulk/","page":"Bulk Operations","title":"Bulk Operations","text":"createMany(model::DataType,\n           data::Vector{<:Dict{String,Any}};\n           chunkSize::Int=1000,\n           transaction::Bool=true)","category":"page"},{"location":"manual/bulk/","page":"Bulk Operations","title":"Bulk Operations","text":"Arguments:\nmodel: the DataType to insert into.\ndata: vector of dicts for each record.\nchunkSize: number of records per batch (default 1000).\ntransaction: wrap each chunk in a transaction (default true).\nReturns: true on success.","category":"page"},{"location":"manual/bulk/","page":"Bulk Operations","title":"Bulk Operations","text":"Example:","category":"page"},{"location":"manual/bulk/","page":"Bulk Operations","title":"Bulk Operations","text":"records = [Dict(\"name\"=>\"User$(i)\",\"email\"=>\"u$(i)@e.com\") for i in 1:5000]\ncreateMany(User, records; chunkSize=500)","category":"page"},{"location":"manual/bulk/","page":"Bulk Operations","title":"Bulk Operations","text":"This will execute 10 batches of 500 inserts each, each inside its own transaction.","category":"page"},{"location":"manual/bulk/","page":"Bulk Operations","title":"Bulk Operations","text":"","category":"page"},{"location":"manual/bulk/#3.-createManyAndReturn-–-Insert-and-Fetch","page":"Bulk Operations","title":"3. createManyAndReturn – Insert & Fetch","text":"","category":"section"},{"location":"manual/bulk/","page":"Bulk Operations","title":"Bulk Operations","text":"createManyAndReturn(model::DataType,\n                    data::Vector{Dict{String,Any}})","category":"page"},{"location":"manual/bulk/","page":"Bulk Operations","title":"Bulk Operations","text":"Performs createMany(model, data) and then calls findMany(model) to return all rows, including newly inserted ones.","category":"page"},{"location":"manual/bulk/","page":"Bulk Operations","title":"Bulk Operations","text":"","category":"page"},{"location":"manual/bulk/#4.-updateManyAndReturn-–-Bulk-Update-and-Fetch","page":"Bulk Operations","title":"4. updateManyAndReturn – Bulk Update & Fetch","text":"","category":"section"},{"location":"manual/bulk/","page":"Bulk Operations","title":"Bulk Operations","text":"updateManyAndReturn(model::DataType,\n                    query::AbstractDict,\n                    data::Dict{String,Any})","category":"page"},{"location":"manual/bulk/","page":"Bulk Operations","title":"Bulk Operations","text":"Arguments:\nmodel: the DataType to update.\nquery: filter dict identifying which rows to update.\ndata: dict of fields to update.\nReturns: Vector{Model}—instances matching the primary key values of updated rows.","category":"page"},{"location":"manual/bulk/","page":"Bulk Operations","title":"Bulk Operations","text":"Example:","category":"page"},{"location":"manual/bulk/","page":"Bulk Operations","title":"Bulk Operations","text":"# Update all users with name \"Bob\" to \"Robert\" and return them\nupdated = updateManyAndReturn(User,\n                              Dict(\"where\"=>Dict(\"name\"=>\"Bob\")),\n                              Dict(\"name\"=>\"Robert\"))","category":"page"},{"location":"manual/bulk/","page":"Bulk Operations","title":"Bulk Operations","text":"","category":"page"},{"location":"manual/bulk/#5.-Performance-Tips","page":"Bulk Operations","title":"5. Performance Tips","text":"","category":"section"},{"location":"manual/bulk/","page":"Bulk Operations","title":"Bulk Operations","text":"Adjust chunkSize based on:\nDatabase max packet sizes\nTransaction latency\nMemory constraints\nUse a single large transaction when atomicity is critical:\nconn = dbConnection()\ntry\n  DBInterface.transaction(conn) do\n    executeQuery(conn, b.sql, b.params; useTransaction=false)\n  end\nfinally\n  releaseConnection(conn)\nend\nBenchmark with BenchmarkTools.jl to find the sweet spot for your workload.","category":"page"},{"location":"manual/bulk/","page":"Bulk Operations","title":"Bulk Operations","text":"","category":"page"},{"location":"manual/bulk/","page":"Bulk Operations","title":"Bulk Operations","text":"With these helpers, OrionORM can scale bulk data operations from hundreds to thousands of rows efficiently and safely.","category":"page"},{"location":"manual/querybuilder/#Query-Builder-Reference","page":"QueryBuilder","title":"Query Builder Reference","text":"","category":"section"},{"location":"manual/querybuilder/","page":"QueryBuilder","title":"QueryBuilder","text":"The Query Builder in OrionORM provides a flexible, Prisma-inspired syntax for constructing SQL queries in Julia. You can filter, sort, paginate, and include related records using simple Julia Dict definitions.","category":"page"},{"location":"manual/querybuilder/","page":"QueryBuilder","title":"QueryBuilder","text":"","category":"page"},{"location":"manual/querybuilder/#1.-Introduction","page":"QueryBuilder","title":"1. Introduction","text":"","category":"section"},{"location":"manual/querybuilder/","page":"QueryBuilder","title":"QueryBuilder","text":"Instead of writing raw SQL, you build a query dictionary that describes:","category":"page"},{"location":"manual/querybuilder/","page":"QueryBuilder","title":"QueryBuilder","text":"where: filtering conditions\nselect: specific columns to retrieve\ninclude: related models to join\norderBy: sorting\nlimit / offset: pagination","category":"page"},{"location":"manual/querybuilder/","page":"QueryBuilder","title":"QueryBuilder","text":"The ORM converts this dictionary into a prepared SQL statement and parameters, then maps the results back to your Julia structs (or Dicts when using include).","category":"page"},{"location":"manual/querybuilder/","page":"QueryBuilder","title":"QueryBuilder","text":"","category":"page"},{"location":"manual/querybuilder/#2.-Basic-Query-Structure","page":"QueryBuilder","title":"2. Basic Query Structure","text":"","category":"section"},{"location":"manual/querybuilder/","page":"QueryBuilder","title":"QueryBuilder","text":"Every dynamic query uses the function:","category":"page"},{"location":"manual/querybuilder/","page":"QueryBuilder","title":"QueryBuilder","text":"buildSelectQuery(::Type{<:ModelType}, query::Dict)","category":"page"},{"location":"manual/querybuilder/","page":"QueryBuilder","title":"QueryBuilder","text":"It returns a NamedTuple(sql, params) suitable for passing to executeQuery.","category":"page"},{"location":"manual/querybuilder/","page":"QueryBuilder","title":"QueryBuilder","text":"tuple = buildSelectQuery(User, Dict(\n  \"where\" => Dict(\"active\" => true),\n  \"orderBy\" => Dict(\"createdAt\" => \"desc\"),\n  \"limit\" => 10\n))\n# tuple.sql    => \"SELECT * FROM User WHERE active = ? ORDER BY createdAt desc LIMIT ?\"\n# tuple.params => [true, 10]","category":"page"},{"location":"manual/querybuilder/","page":"QueryBuilder","title":"QueryBuilder","text":"","category":"page"},{"location":"manual/querybuilder/#3.-Filtering-with-where","page":"QueryBuilder","title":"3. Filtering with where","text":"","category":"section"},{"location":"manual/querybuilder/","page":"QueryBuilder","title":"QueryBuilder","text":"The where key accepts a nested Dict describing conditions. Supported operators:","category":"page"},{"location":"manual/querybuilder/","page":"QueryBuilder","title":"QueryBuilder","text":"Operator Julia syntax SQL translation\nEquals \"name\"=>\"Alice\" name = 'Alice'\ngt / lt \"age\"=>Dict(\"gt\"=>18) age > 18\ngte / lte \"score\"=>Dict(\"gte\"=>100) score >= 100\nin / notIn \"id\"=>Dict(\"in\"=>[1,2,3]) id IN (1,2,3)\ncontains \"email\"=>Dict(\"contains\"=>\"@\") email LIKE '%@%'\nstartsWith \"name\"=>Dict(\"startsWith\"=>\"A\") name LIKE 'A%'\nendsWith \"name\"=>Dict(\"endsWith\"=>\"son\") name LIKE '%son'","category":"page"},{"location":"manual/querybuilder/#3.1-Nested-Logic","page":"QueryBuilder","title":"3.1 Nested Logic","text":"","category":"section"},{"location":"manual/querybuilder/","page":"QueryBuilder","title":"QueryBuilder","text":"You can combine multiple filters with AND, OR, and not:","category":"page"},{"location":"manual/querybuilder/","page":"QueryBuilder","title":"QueryBuilder","text":"# (age > 18 AND active = true) OR email contains \"@example.com\"\nwhere = Dict(\n  \"OR\" => [\n    Dict(\"AND\" => [Dict(\"age\"=>Dict(\"gt\"=>18)), Dict(\"active\"=>true)]),\n    Dict(\"email\"=>Dict(\"contains\"=>\"@example.com\"))\n  ]\n)","category":"page"},{"location":"manual/querybuilder/","page":"QueryBuilder","title":"QueryBuilder","text":"","category":"page"},{"location":"manual/querybuilder/#4.-Selecting-Specific-Columns","page":"QueryBuilder","title":"4. Selecting Specific Columns","text":"","category":"section"},{"location":"manual/querybuilder/","page":"QueryBuilder","title":"QueryBuilder","text":"Use the select key to retrieve only certain fields:","category":"page"},{"location":"manual/querybuilder/","page":"QueryBuilder","title":"QueryBuilder","text":"query = Dict(\n  \"select\" => [\"id\",\"name\",\"email\"]\n)\nb = buildSelectQuery(User, query)\n# SQL: SELECT id,name,email FROM User","category":"page"},{"location":"manual/querybuilder/","page":"QueryBuilder","title":"QueryBuilder","text":"If no select is provided, the builder defaults to * (all columns).","category":"page"},{"location":"manual/querybuilder/","page":"QueryBuilder","title":"QueryBuilder","text":"","category":"page"},{"location":"manual/querybuilder/#5.-Sorting-and-Pagination","page":"QueryBuilder","title":"5. Sorting and Pagination","text":"","category":"section"},{"location":"manual/querybuilder/","page":"QueryBuilder","title":"QueryBuilder","text":"orderBy: a String or Dict of column=>\"asc\"/\"desc\"\nlimit: maximum number of rows\noffset: number of rows to skip","category":"page"},{"location":"manual/querybuilder/","page":"QueryBuilder","title":"QueryBuilder","text":"query = Dict(\n  \"orderBy\" => Dict(\"createdAt\"=>\"desc\"),\n  \"limit\" => 20,\n  \"offset\" => 40\n)","category":"page"},{"location":"manual/querybuilder/","page":"QueryBuilder","title":"QueryBuilder","text":"Generates: ... ORDER BY createdAt desc LIMIT ? OFFSET ?","category":"page"},{"location":"manual/querybuilder/","page":"QueryBuilder","title":"QueryBuilder","text":"","category":"page"},{"location":"manual/querybuilder/#6.-Including-Related-Models","page":"QueryBuilder","title":"6. Including Related Models","text":"","category":"section"},{"location":"manual/querybuilder/","page":"QueryBuilder","title":"QueryBuilder","text":"To fetch parent and child records in a single query, use the include key with a vector of models:","category":"page"},{"location":"manual/querybuilder/","page":"QueryBuilder","title":"QueryBuilder","text":"results = findMany(User; query=Dict(\n  \"include\" => [Post],\n  \"where\"   => Dict(\"active\"=>true)\n))","category":"page"},{"location":"manual/querybuilder/","page":"QueryBuilder","title":"QueryBuilder","text":"Under the hood, OrionORM uses a LEFT JOIN for each included model, ensuring users with no posts still appear. The return value is:","category":"page"},{"location":"manual/querybuilder/","page":"QueryBuilder","title":"QueryBuilder","text":"Vector{Dict{String,Any}}\n# each element: Dict(\n#   \"User\" => User(...),\n#   \"Post\" => Vector{Post}(...)\n# )","category":"page"},{"location":"manual/querybuilder/","page":"QueryBuilder","title":"QueryBuilder","text":"","category":"page"},{"location":"manual/querybuilder/#7.-Example:-Combined-Query","page":"QueryBuilder","title":"7. Example: Combined Query","text":"","category":"section"},{"location":"manual/querybuilder/","page":"QueryBuilder","title":"QueryBuilder","text":"q = Dict(\n  \"where\"   => Dict(\"active\"=>true, \"age\"=>Dict(\"gte\"=>21)),\n  \"select\"  => [\"id\",\"name\"],\n  \"include\" => [Post],\n  \"orderBy\" => Dict(\"name\"=>\"asc\"),\n  \"limit\"   => 5\n)\n\nconn = dbConnection()\n(b.sql, b.params) = buildSelectQuery(User, q)\nresults = executeQuery(conn, b.sql, b.params)\nreleaseConnection(conn)","category":"page"},{"location":"manual/querybuilder/","page":"QueryBuilder","title":"QueryBuilder","text":"This returns up to 5 active users aged 21+ with only their id and name fields, each enriched with their posts.","category":"page"},{"location":"Reference/relationship/#Relationship","page":"Relationship","title":"Relationship","text":"","category":"section"},{"location":"Reference/relationship/#Introduction","page":"Relationship","title":"Introduction","text":"","category":"section"},{"location":"Reference/relationship/","page":"Relationship","title":"Relationship","text":"OrionORM.jl is an ORM for Julia that simplifies defining models and managing relationships between them. With OrionORM.jl, you can define relationships such as:","category":"page"},{"location":"Reference/relationship/","page":"Relationship","title":"Relationship","text":"hasMany: A record in one model has many related records in another model.\nbelongsTo: A record in one model belongs to a record in another model.\nhasOne: A record in one model has a single related record in another model.","category":"page"},{"location":"Reference/relationship/","page":"Relationship","title":"Relationship","text":"In addition, OrionORM.jl allows you to enrich query results using the \"include\" key in a query dictionary. This way, you can return related data as part of a Dict (for single record queries) or a vector of Dicts (for multiple records).","category":"page"},{"location":"Reference/relationship/#Creating-Models-with-Relationships","page":"Relationship","title":"Creating Models with Relationships","text":"","category":"section"},{"location":"Reference/relationship/","page":"Relationship","title":"Relationship","text":"To define models along with their relationships, use the @Model macro. For example:","category":"page"},{"location":"Reference/relationship/","page":"Relationship","title":"Relationship","text":"Model(\n    :User,\n    [\n        (\"id\", INTEGER(), [PrimaryKey(), AutoIncrement()]),\n        (\"name\", TEXT(), [NotNull()]),\n        (\"email\", TEXT(), [Unique(), NotNull()])\n    ],\n    [\n        (\"posts\", Post, \"authorId\", :hasMany)\n    ]\n)\n\nModel(\n    :Post,\n    [\n        (\"id\", INTEGER(), [PrimaryKey(), AutoIncrement()]),\n        (\"title\", TEXT(), [NotNull()]),\n        (\"authorId\", INTEGER(), [NotNull()])\n    ],\n    [\n        (\"User\", User, \"id\", :belongsTo)\n    ]\n)","category":"page"},{"location":"Reference/relationship/","page":"Relationship","title":"Relationship","text":"In this example:","category":"page"},{"location":"Reference/relationship/","page":"Relationship","title":"Relationship","text":"A User has many Post records through a hasMany relationship (the authorId field in Post references the id field in User).\nA Post belongs to a User via a belongsTo relationship (the authorId field in Post references the id field in User).","category":"page"},{"location":"Reference/relationship/#Querying-with-the-\"include\"-Parameter","page":"Relationship","title":"Querying with the \"include\" Parameter","text":"","category":"section"},{"location":"Reference/relationship/","page":"Relationship","title":"Relationship","text":"When using the \"include\" parameter in your queries, OrionORM.jl enriches the result with related records. Depending on the relationship type, the return format will be:","category":"page"},{"location":"Reference/relationship/","page":"Relationship","title":"Relationship","text":"hasMany/hasOne: The result will include, under the key of the related model, either a vector of Dicts (for hasMany) or a single Dict (for hasOne).\nbelongsTo: The result will include a single Dict with the parent record's data.","category":"page"},{"location":"Reference/relationship/#Example-1:-Query-with-belongsTo","page":"Relationship","title":"Example 1: Query with belongsTo","text":"","category":"section"},{"location":"Reference/relationship/","page":"Relationship","title":"Relationship","text":"result = findFirst(Post; query=Dict(\"where\" => Dict(\"id\" => 1), \"include\" => [\"User\"]))","category":"page"},{"location":"Reference/relationship/","page":"Relationship","title":"Relationship","text":"Assuming the post with id = 1 belongs to a user, the result will be a Dict similar to:","category":"page"},{"location":"Reference/relationship/","page":"Relationship","title":"Relationship","text":"Dict(\n    \"id\" => 1,\n    \"title\" => \"Example Post\",\n    \"authorId\" => 10,\n    \"User\" => Dict(\"id\" => 10, \"name\" => \"Thalles\", \"email\" => \"thalles@example.com\")\n)","category":"page"},{"location":"Reference/relationship/#Example-2:-Query-with-hasMany","page":"Relationship","title":"Example 2: Query with hasMany","text":"","category":"section"},{"location":"Reference/relationship/","page":"Relationship","title":"Relationship","text":"results = findMany(User; query=Dict(\"where\" => Dict(\"name\" => \"Thiago\"), \"include\" => [\"Post\"]))","category":"page"},{"location":"Reference/relationship/","page":"Relationship","title":"Relationship","text":"Each item in results will be a Dict structured as follows:","category":"page"},{"location":"Reference/relationship/","page":"Relationship","title":"Relationship","text":"Dict(\n    \"id\" => 10,\n    \"name\" => \"Thiago\",\n    \"email\" => \"thiago@example.com\",\n    \"Post\" => [\n         Dict(\"id\" => 1, \"title\" => \"First Post\", \"authorId\" => 10),\n         Dict(\"id\" => 2, \"title\" => \"Second Post\", \"authorId\" => 10)\n    ]\n)","category":"page"},{"location":"Reference/relationship/#Internal-Workflow","page":"Relationship","title":"Internal Workflow","text":"","category":"section"},{"location":"Reference/relationship/","page":"Relationship","title":"Relationship","text":"When a query is executed with the \"include\" parameter, the workflow is as follows:","category":"page"},{"location":"Reference/relationship/","page":"Relationship","title":"Relationship","text":"Main Query:   The findFirst or findMany function builds an SQL query to fetch records from the base model (e.g., User or Post).\nSerialization:   Each returned record is converted into a simple Dict (using a helper function like serialize or convertRowToDict).\nEnrichment:   The ORM goes through the list of models specified in \"include\". For each included model, it:\nFinds the registered relationship (using getRelationships and resolveModel).\nExecutes a separate query (via hasMany, hasOne, or belongsTo) to fetch related records.\nAdds the related data to the main record’s Dict under a key corresponding to the related model.","category":"page"},{"location":"Reference/relationship/#Example-Tests","page":"Relationship","title":"Example Tests","text":"","category":"section"},{"location":"Reference/relationship/","page":"Relationship","title":"Relationship","text":"Below is an excerpt of unit tests that demonstrate the use of relationships and the \"include\" parameter:","category":"page"},{"location":"Reference/relationship/","page":"Relationship","title":"Relationship","text":"@testset \"SimpleORM Basic CRUD Tests\" begin\n    # Create a user\n    userData = Dict(\"name\" => \"Thiago\", \"email\" => \"thiago@example.com\", \"cpf\" => \"00000000000\")\n    user = create(User, userData)\n    @test user.name == \"Thiago\"\n    @test user.email == \"thiago@example.com\"\n    @test hasproperty(user, :id)\n\n    # Create a post related to the user\n    postData = Dict(\"title\" => \"My First Post\", \"authorId\" => user.id)\n    post = create(Post, postData)\n    @test post.title == \"My First Post\"\n    @test post.authorId == user.id\n\n    # Query with \"include\" to fetch the user and their posts\n    result = findFirst(User; query=Dict(\"where\" => Dict(\"name\" => \"Thiago\"), \"include\" => [\"Post\"]))\n    @test result[\"id\"] == user.id\n    @test typeof(result[\"Post\"]) == Vector\n    @test result[\"Post\"][1][\"title\"] == \"My First Post\"\n\n    # Query with belongsTo: fetch the post and include the user\n    result2 = findFirst(Post; query=Dict(\"where\" => Dict(\"id\" => post.id), \"include\" => [\"User\"]))\n    @test result2[\"id\"] == post.id\n    @test typeof(result2[\"User\"]) == Dict\n    @test result2[\"User\"][\"id\"] == user.id\nend","category":"page"},{"location":"Reference/relationship/#Conclusion","page":"Relationship","title":"Conclusion","text":"","category":"section"},{"location":"Reference/relationship/","page":"Relationship","title":"Relationship","text":"With OrionORM.jl, you can easily define models with relationships and perform enriched queries using the \"include\" parameter. This modular approach allows you to build complex queries without manually writing SQL, returning structured results as Dicts that simplify data consumption in your application.","category":"page"},{"location":"Reference/relationship/","page":"Relationship","title":"Relationship","text":"Feel free to contribute suggestions or ask questions if you need further details!","category":"page"},{"location":"#OrionORM.jl","page":"Home","title":"OrionORM.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Easy ORM for Julia.","category":"page"},{"location":"#Package-Features","page":"Home","title":"Package Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Models: conversion, instantiation;\nCRUD functions;\nDatabase connection using .env file;\nMySQL Support;\nRelationships.","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"manual/configuration/#Configuration-and-Best-Practices","page":"Configuration","title":"Configuration & Best Practices","text":"","category":"section"},{"location":"manual/configuration/","page":"Configuration","title":"Configuration","text":"This guide covers environment setup, logging, and security considerations when using OrionORM in production.","category":"page"},{"location":"manual/configuration/","page":"Configuration","title":"Configuration","text":"","category":"page"},{"location":"manual/configuration/#1.-Environment-Variables","page":"Configuration","title":"1. Environment Variables","text":"","category":"section"},{"location":"manual/configuration/","page":"Configuration","title":"Configuration","text":"OrionORM uses DotEnv.jl to load database credentials and pool settings. Create a .env file at your project root:","category":"page"},{"location":"manual/configuration/","page":"Configuration","title":"Configuration","text":"DB_HOST=localhost\nDB_USER=root\nDB_PASSWORD=supersecret\nDB_NAME=myapp_db\nDB_PORT=3306\nPOOL_SIZE=10              # default is 5\nORIONORM_LOG_LEVEL=info   # error, warn, info, debug","category":"page"},{"location":"manual/configuration/","page":"Configuration","title":"Configuration","text":"Load variables at startup:","category":"page"},{"location":"manual/configuration/","page":"Configuration","title":"Configuration","text":"using DotEnv; DotEnv.load!()\nusing OrionORM","category":"page"},{"location":"manual/configuration/","page":"Configuration","title":"Configuration","text":"","category":"page"},{"location":"manual/configuration/#2.-Logging","page":"Configuration","title":"2. Logging","text":"","category":"section"},{"location":"manual/configuration/","page":"Configuration","title":"Configuration","text":"Set ORIONORM_LOG_LEVEL to control verbosity:\nerror: only SQL errors\nwarn: warnings and errors\ninfo: queries + warnings\ndebug: detailed internal logs","category":"page"},{"location":"manual/configuration/","page":"Configuration","title":"Configuration","text":"Customize globally:","category":"page"},{"location":"manual/configuration/","page":"Configuration","title":"Configuration","text":"ENV[\"ORIONORM_LOG_LEVEL\"] = \"debug\"\ninitLogger()","category":"page"},{"location":"manual/configuration/","page":"Configuration","title":"Configuration","text":"Remember: logging takes time and storage.","category":"page"},{"location":"manual/configuration/","page":"Configuration","title":"Configuration","text":"","category":"page"},{"location":"manual/configuration/#3.-Connection-Pool-Tuning","page":"Configuration","title":"3. Connection Pool Tuning","text":"","category":"section"},{"location":"manual/configuration/","page":"Configuration","title":"Configuration","text":"POOL_SIZE: number of live connections to maintain. Increase for high concurrency.\nMonitor active vs. idle connections:\n@info \"Pool available: $(Pool.connection_pool.n_avail_items)\"","category":"page"},{"location":"manual/configuration/","page":"Configuration","title":"Configuration","text":"Avoid exhausting the pool:","category":"page"},{"location":"manual/configuration/","page":"Configuration","title":"Configuration","text":"Always call releaseConnection(conn) in a finally block.\nFor short-lived apps or scripts, consider lowering POOL_SIZE.","category":"page"},{"location":"manual/configuration/","page":"Configuration","title":"Configuration","text":"","category":"page"},{"location":"manual/configuration/#4.-Security-and-Secrets-Management","page":"Configuration","title":"4. Security & Secrets Management","text":"","category":"section"},{"location":"manual/configuration/","page":"Configuration","title":"Configuration","text":"Don’t commit .env to your repo. Use a secrets manager (e.g., Vault) in production. (!!!)\nEncrypt credentials at rest and load them via environment injection pipelines.\nRotate database credentials regularly and leverage connection string parameters for SSL/TLS.","category":"page"},{"location":"manual/configuration/","page":"Configuration","title":"Configuration","text":"","category":"page"},{"location":"manual/configuration/#5.-SQL-Injection-Prevention","page":"Configuration","title":"5. SQL Injection Prevention","text":"","category":"section"},{"location":"manual/configuration/","page":"Configuration","title":"Configuration","text":"Always use executeQuery with parameters (never string interpolation).\nThe QueryBuilder escapes identifiers and sanitizes literals before binding.","category":"page"},{"location":"manual/configuration/","page":"Configuration","title":"Configuration","text":"Bad (vulnerable):","category":"page"},{"location":"manual/configuration/","page":"Configuration","title":"Configuration","text":"sql = \"SELECT * FROM users WHERE name = ‘$(user_input)’\"\nDBInterface.execute(conn, sql)","category":"page"},{"location":"manual/configuration/","page":"Configuration","title":"Configuration","text":"Good (safe):","category":"page"},{"location":"manual/configuration/","page":"Configuration","title":"Configuration","text":"executeQuery(conn,\n    \"SELECT * FROM users WHERE name = ?\",\n    [user_input]\n)","category":"page"},{"location":"manual/configuration/","page":"Configuration","title":"Configuration","text":"","category":"page"},{"location":"manual/configuration/","page":"Configuration","title":"Configuration","text":"With this configuration guide, you can securely and efficiently run OrionORM in development, staging, and production environments.","category":"page"},{"location":"manual/errors/#Error-Handling-and-Troubleshooting","page":"Error Handling","title":"Error Handling & Troubleshooting","text":"","category":"section"},{"location":"manual/errors/","page":"Error Handling","title":"Error Handling","text":"This guide covers the common exceptions, error messages, and debugging techniques in OrionORM. Proper error handling ensures robust applications and simplifies troubleshooting.","category":"page"},{"location":"manual/errors/","page":"Error Handling","title":"Error Handling","text":"","category":"page"},{"location":"manual/errors/#1.-Debugging-SQL","page":"Error Handling","title":"1. Debugging SQL","text":"","category":"section"},{"location":"manual/errors/","page":"Error Handling","title":"Error Handling","text":"Enable Info Logging:\nENV[\"ORIONORM_LOG_LEVEL\"] = \"info\"\nCheck Logs: Every call to executeQuery logs:\nsql: the prepared SQL string\nargs: the parameter vector\nReproduce in MySQL client:\nCopy the logged SQL, replace ? with actual values, and run in mysql CLI or GUI.\nInspect Generated Query:\nb = buildSelectQuery(User, qdict)\nprintln(b.sql, \"\\nParams:\", b.params)","category":"page"},{"location":"manual/errors/","page":"Error Handling","title":"Error Handling","text":"","category":"page"},{"location":"manual/errors/#2.-Handling-commands-out-of-sync","page":"Error Handling","title":"2. Handling commands out of sync","text":"","category":"section"},{"location":"manual/errors/","page":"Error Handling","title":"Error Handling","text":"This error arises when statements remain open or connections are reused improperly. To resolve:","category":"page"},{"location":"manual/errors/","page":"Error Handling","title":"Error Handling","text":"Ensure every DBInterface.prepare is paired with DBInterface.close!(stmt) in a finally block.\nUse the unified executeQuery which guarantees closing statements.\nDo not call raw DBInterface.execute on a connection with unclosed statements.","category":"page"},{"location":"manual/errors/","page":"Error Handling","title":"Error Handling","text":"","category":"page"},{"location":"manual/errors/#3.-Transaction-Rollback","page":"Error Handling","title":"3. Transaction Rollback","text":"","category":"section"},{"location":"manual/errors/","page":"Error Handling","title":"Error Handling","text":"Within a DBInterface.transaction(conn) block, any uncaught exception triggers a rollback:","category":"page"},{"location":"manual/errors/","page":"Error Handling","title":"Error Handling","text":"conn = dbConnection()\ntry\n  DBInterface.transaction(conn) do\n    executeQuery(conn, sql1, params1; useTransaction=false)\n    error(\"trigger rollback\")\n  end\ncatch e\n  @info \"Transaction rolled back due to: $e\"\nfinally\n  releaseConnection(conn)\nend","category":"page"}]
}
